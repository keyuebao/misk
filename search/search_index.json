{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Misk is a new open source application container from Cash App. Misk is not ready for use. The API is not stable. Releases \u00b6 Our change log has release history. API is subject to change. implementation ( \"com.squareup.misk:misk:0.21.0\" ) Snapshot builds are available . Modules \u00b6 misk-actions \u00b6 The core annotations and interfaces necessary to define actions that can be hosted in Misk. This package has no dependency on the enclosing container (Misk!) and so your actions can be used in other environments without any heavy dependencies. Actions should extend WebAction , be annotated with a HTTP method like @Post , accept a request object and return a response object. Throw an exception like BadRequestException to fail the request without much boilerplate. misk-aws \u00b6 Integrate with Amazon Web Services, and includes packages to integrate with S3 and SQS. misk-aws-dynamodb \u00b6 Integrate with AWS DynamoDb using AWS SDK for Java 1.x. It should be safe to install side-by-side with misk-aws2-dynamodb if you need to use features in both. misk-aws-dynamodb-testing \u00b6 Integrate with this package to write tests for code that interacts with DynamoDb. Exposes APIs via AWS SDK for Java 1.x. Use alongside with misk-aws-dynamodb . Installing InProcessDynamoDbModule runs a DynamoDb Local instance in memory for your tests to run against. This module is recommended over DockerDynamoDbModule because there is less overhead in test execution performance. Installing DockerDynamoDbModule runs a DynamoDB Local instance in Docker for your tests to execute against. misk-aws2-dynamodb \u00b6 Integrate with AWS DynamoDb using AWS SDK for Java 2.x. It should be safe to install side-by-side with misk-aws-dynamodb if you need to use features in both. Please read the AWS SDK for Java 2.x Migration Guide for more details. misk-aws2-dynamodb-testing \u00b6 Integrate with this package to write tests for code that interacts with DynamoDb. Exposes APIs via AWS SDK for Java 2.x. Use alongside with misk-aws2-dynamodb . Installing InProcessDynamoDbModule runs a DynamoDb Local instance in memory for your tests to run against. This module is recommended over DockerDynamoDbModule because there is less overhead in test execution performance. Installing DockerDynamoDbModule runs a DynamoDB Local instance in Docker for your tests to execute against. misk-service \u00b6 Bind Guava services with inter-service dependencies. Any service can depend on any other service. ServiceManager won\u2019t start a service until the services it depends on are running. misk-inject \u00b6 Integrates Guice with Kotlin. Extending KAbstractModule instead of Guice\u2019s AbstractModule lets you use KClass instead of java.lang.Class and other conveniences. misk-feature \u00b6 Runtime feature flags. misk-launchdarkly is the reference implementation. misk-jobqueue \u00b6 A job queue with a high quality fake. AwsSqsJobQueueModule from misk-aws is the reference implementation. misk-events \u00b6 An event publisher + consumer. There is no open source reference implementation at this time. Looking for Misk-Web? \u00b6 Misk-Web powers the Misk Admin Dashboard with modular Typescript + React powered tabs. Check out Misk-Web ! What are the wisp* modules? \u00b6 The wisp* modules contain no Dependency Injection based code (i.e. no Guice, etc). These modules should never refer to misk* modules, although misk* modules can (and should) use wisp* modules. Also, modules that are wisp*-testing will only be used in test scope in other wisp modules, never in the api/implementation scope. If you are refactoring code from misk into the wisp modules, you must not break any external Misk dependencies or apis. It is ok to deprecate items in misk to encourage eventual migration to wisp directly if desired. If your refactoring does not fit one of the existing wisp modules, create a new module. For now, it is preferred to have many small modules rather than larger conglomerate modules requiring many different dependencies. It should be considered that wisp will be volatile for sometime with the potential for a lot of changes, additions, etc. Misk apps should use wisp modules directly with caution as breaking changes might be required.","title":"Overview"},{"location":"#releases","text":"Our change log has release history. API is subject to change. implementation ( \"com.squareup.misk:misk:0.21.0\" ) Snapshot builds are available .","title":"Releases"},{"location":"#modules","text":"","title":"Modules"},{"location":"#misk-actions","text":"The core annotations and interfaces necessary to define actions that can be hosted in Misk. This package has no dependency on the enclosing container (Misk!) and so your actions can be used in other environments without any heavy dependencies. Actions should extend WebAction , be annotated with a HTTP method like @Post , accept a request object and return a response object. Throw an exception like BadRequestException to fail the request without much boilerplate.","title":"misk-actions"},{"location":"#misk-aws","text":"Integrate with Amazon Web Services, and includes packages to integrate with S3 and SQS.","title":"misk-aws"},{"location":"#misk-aws-dynamodb","text":"Integrate with AWS DynamoDb using AWS SDK for Java 1.x. It should be safe to install side-by-side with misk-aws2-dynamodb if you need to use features in both.","title":"misk-aws-dynamodb"},{"location":"#misk-aws-dynamodb-testing","text":"Integrate with this package to write tests for code that interacts with DynamoDb. Exposes APIs via AWS SDK for Java 1.x. Use alongside with misk-aws-dynamodb . Installing InProcessDynamoDbModule runs a DynamoDb Local instance in memory for your tests to run against. This module is recommended over DockerDynamoDbModule because there is less overhead in test execution performance. Installing DockerDynamoDbModule runs a DynamoDB Local instance in Docker for your tests to execute against.","title":"misk-aws-dynamodb-testing"},{"location":"#misk-aws2-dynamodb","text":"Integrate with AWS DynamoDb using AWS SDK for Java 2.x. It should be safe to install side-by-side with misk-aws-dynamodb if you need to use features in both. Please read the AWS SDK for Java 2.x Migration Guide for more details.","title":"misk-aws2-dynamodb"},{"location":"#misk-aws2-dynamodb-testing","text":"Integrate with this package to write tests for code that interacts with DynamoDb. Exposes APIs via AWS SDK for Java 2.x. Use alongside with misk-aws2-dynamodb . Installing InProcessDynamoDbModule runs a DynamoDb Local instance in memory for your tests to run against. This module is recommended over DockerDynamoDbModule because there is less overhead in test execution performance. Installing DockerDynamoDbModule runs a DynamoDB Local instance in Docker for your tests to execute against.","title":"misk-aws2-dynamodb-testing"},{"location":"#misk-service","text":"Bind Guava services with inter-service dependencies. Any service can depend on any other service. ServiceManager won\u2019t start a service until the services it depends on are running.","title":"misk-service"},{"location":"#misk-inject","text":"Integrates Guice with Kotlin. Extending KAbstractModule instead of Guice\u2019s AbstractModule lets you use KClass instead of java.lang.Class and other conveniences.","title":"misk-inject"},{"location":"#misk-feature","text":"Runtime feature flags. misk-launchdarkly is the reference implementation.","title":"misk-feature"},{"location":"#misk-jobqueue","text":"A job queue with a high quality fake. AwsSqsJobQueueModule from misk-aws is the reference implementation.","title":"misk-jobqueue"},{"location":"#misk-events","text":"An event publisher + consumer. There is no open source reference implementation at this time.","title":"misk-events"},{"location":"#looking-for-misk-web","text":"Misk-Web powers the Misk Admin Dashboard with modular Typescript + React powered tabs. Check out Misk-Web !","title":"Looking for Misk-Web?"},{"location":"#what-are-the-wisp-modules","text":"The wisp* modules contain no Dependency Injection based code (i.e. no Guice, etc). These modules should never refer to misk* modules, although misk* modules can (and should) use wisp* modules. Also, modules that are wisp*-testing will only be used in test scope in other wisp modules, never in the api/implementation scope. If you are refactoring code from misk into the wisp modules, you must not break any external Misk dependencies or apis. It is ok to deprecate items in misk to encourage eventual migration to wisp directly if desired. If your refactoring does not fit one of the existing wisp modules, create a new module. For now, it is preferred to have many small modules rather than larger conglomerate modules requiring many different dependencies. It should be considered that wisp will be volatile for sometime with the potential for a lot of changes, additions, etc. Misk apps should use wisp modules directly with caution as breaking changes might be required.","title":"What are the wisp* modules?"},{"location":"actions/","text":"Actions \u00b6 Actions are Misk\u2019s unit for an endpoint. Misk lets you make HTTP actions, and gRPC actions via Wire . Web Actions \u00b6 Below are some example Web action declarations. Note that many of the annotations are optional. GET: @Singleton class HelloWebAction @Inject constructor () : WebAction { @Get ( \"/hello/{name}\" ) // Enclose path parameters in {} @ResponseContentType ( MediaTypes . APPLICATION_JSON ) @Authenticated ( services = [ \"my-other-app\" ] , capabilities = [ \"my-app_owners\" ] ) fun hello ( // Use @PathParam with the name of the param. Required if there's a param in the path pattern. @PathParam name : String , // RequestHeaders is optional: @RequestHeaders headers : Headers , // QueryParams are optional: @QueryParam nickName : String? , // e.g. /hello/abc?nickName=def @QueryParam greetings : List < String >? // e.g. /hello/abc?greetings=def&greetings=ghi ): HelloResponse { return HelloResponse ( name ) } } POST: @Singleton class HelloWebPostAction @Inject constructor () : WebAction { @Post ( \"/hello/{name}\" ) @RequestContentType ( MediaTypes . APPLICATION_JSON ) @ResponseContentType ( MediaTypes . APPLICATION_JSON ) @Authenticated ( services = [ \"my-other-app\" ] , capabilities = [ \"my-app_owners\" ] ) fun hello ( @PathParam name : String , // RequestBody is optional, and is automatically deserialized to the provided type. @RequestBody body : PostBody ): HelloPostResponse { return HelloPostResponse ( body . greeting , name ) } } data class HelloPostResponse ( val greeting : String , val name : String ) data class PostBody ( val greeting : String ) Setting up HTTP actions \u00b6 Install the action into a module: class HelloModule : KAbstractModule () { override fun configure () { install ( WebActionModule . create < HelloWebAction > ()) install ( WebActionModule . create < HelloWebPostAction > ()) } } And then put that module onto the top level MiskApplication . fun main ( args : Array < String > ) { MiskApplication ( // ... HelloModule (), // new! ). run ( args ) } Response type \u00b6 If you change the action\u2019s response type to Response<T> , it gives you better control over the response status code and headers. @Singleton class HelloWebResponseAction @Inject constructor () : WebAction { @Get ( \"/hello_but_203/{name}\" ) @ResponseContentType ( MediaTypes . APPLICATION_JSON ) fun hello ( @PathParam name : String ): Response < HelloResponse > = Response ( statusCode = 203 , headers = headersOf (), body = HelloResponse () ) } It\u2019s also possible to throw exceptions that are mapped to status codes. @Singleton class HelloWebResponseAction @Inject constructor () : WebAction { @Get ( \"/no_access/{name}\" ) fun hello ( @PathParam name : String ): HelloResponse { throw UnauthenticatedException () } } gRPC Actions \u00b6 Misk has support for gRPC actions via the Wire protocol buffer (protobuf) library. To create a gRPC action, first define the relevant protos for your service. Let\u2019s say we\u2019re creating a GreeterService that exposes one API, Hello . Create this file in src/main/proto/hello.proto : syntax = \"proto2\" ; package squareup . cash.hello ; option java_package = \"com.squareup.protos.cash.hello\" ; message HelloRequest { optional string message = 1 ; } message HelloResponse { optional string message = 1 ; } service GreeterService { rpc Hello ( HelloRequest ) returns ( HelloResponse ) {} } Next, in your project\u2019s build file (for this example, build.gradle.kts ), add a dependency on the wire plugin: plugins { id(\"com.squareup.wire\") } Add the following configuration to generate the gRPC interfaces for your service: wire { sourcePath { srcDir(\"src/main/proto\") } kotlin { include(\"squareup.cash.hello.GreeterService\") rpcCallStyle = \"blocking\" rpcRole = \"server\" singleMethodServices = true } java { } } Finally, implement and bind your gRPC action. GreeterServiceHelloBlockingServer is generated by Wire. @Singleton class HelloGrpcAction @Inject internal constructor () : GreeterServiceHelloBlockingServer , WebAction { @Unauthorized override fun Hello ( request : HelloRequest ): HelloResponse { return HelloResponse ( \"message\" ) } } // This module binds HelloGrpcAction. class GreeterActionModule : KAbstractModule () { override fun configure () { install ( WebActionModule . create < HelloGrpcAction > ()) } } Creating a gRPC action automatically creates a JSON endpoint with all of the same annotations in the path defined by the ...BlockingServer , typically /<package>.<service name>/<rpc name> . You can also create a second class that extends WebAction to customize this further. Read more about HTTP actions in Web Actions . If you\u2019re building both a gRPC and a HTTP action, a common pattern is to have them both use a common dependency: @Singleton class HelloGrpcAction @Inject constructor ( val greeter : Greeter ) : GreeterServiceHelloBlockingServer , WebAction { @Unauthorized override fun hello () = HelloResponse ( greeter . greet ()) } @Singleton class HelloWebAction @Inject constructor ( val greeter : Greeter ) : WebAction { @Unauthorized @Get ( \"/hello\" ) @ResponseContentType ( MediaTypes . APPLICATION_JSON ) fun hello () = HelloResponse ( greeter . greet ()) } @Singleton class Greeter @Inject constructor () { fun greet () = \"Hello world\" } ActionScoped \u00b6 ActionScoped gives an action access to context produced by the action\u2019s interceptors. Misk has a few ActionScoped items built in: MiskCaller - access derived authorization details HttpCall - access lower level HTTP details, e.g. request headers","title":"Actions"},{"location":"actions/#actions","text":"Actions are Misk\u2019s unit for an endpoint. Misk lets you make HTTP actions, and gRPC actions via Wire .","title":"Actions"},{"location":"actions/#web-actions","text":"Below are some example Web action declarations. Note that many of the annotations are optional. GET: @Singleton class HelloWebAction @Inject constructor () : WebAction { @Get ( \"/hello/{name}\" ) // Enclose path parameters in {} @ResponseContentType ( MediaTypes . APPLICATION_JSON ) @Authenticated ( services = [ \"my-other-app\" ] , capabilities = [ \"my-app_owners\" ] ) fun hello ( // Use @PathParam with the name of the param. Required if there's a param in the path pattern. @PathParam name : String , // RequestHeaders is optional: @RequestHeaders headers : Headers , // QueryParams are optional: @QueryParam nickName : String? , // e.g. /hello/abc?nickName=def @QueryParam greetings : List < String >? // e.g. /hello/abc?greetings=def&greetings=ghi ): HelloResponse { return HelloResponse ( name ) } } POST: @Singleton class HelloWebPostAction @Inject constructor () : WebAction { @Post ( \"/hello/{name}\" ) @RequestContentType ( MediaTypes . APPLICATION_JSON ) @ResponseContentType ( MediaTypes . APPLICATION_JSON ) @Authenticated ( services = [ \"my-other-app\" ] , capabilities = [ \"my-app_owners\" ] ) fun hello ( @PathParam name : String , // RequestBody is optional, and is automatically deserialized to the provided type. @RequestBody body : PostBody ): HelloPostResponse { return HelloPostResponse ( body . greeting , name ) } } data class HelloPostResponse ( val greeting : String , val name : String ) data class PostBody ( val greeting : String )","title":"Web Actions"},{"location":"actions/#setting-up-http-actions","text":"Install the action into a module: class HelloModule : KAbstractModule () { override fun configure () { install ( WebActionModule . create < HelloWebAction > ()) install ( WebActionModule . create < HelloWebPostAction > ()) } } And then put that module onto the top level MiskApplication . fun main ( args : Array < String > ) { MiskApplication ( // ... HelloModule (), // new! ). run ( args ) }","title":"Setting up HTTP actions"},{"location":"actions/#response-type","text":"If you change the action\u2019s response type to Response<T> , it gives you better control over the response status code and headers. @Singleton class HelloWebResponseAction @Inject constructor () : WebAction { @Get ( \"/hello_but_203/{name}\" ) @ResponseContentType ( MediaTypes . APPLICATION_JSON ) fun hello ( @PathParam name : String ): Response < HelloResponse > = Response ( statusCode = 203 , headers = headersOf (), body = HelloResponse () ) } It\u2019s also possible to throw exceptions that are mapped to status codes. @Singleton class HelloWebResponseAction @Inject constructor () : WebAction { @Get ( \"/no_access/{name}\" ) fun hello ( @PathParam name : String ): HelloResponse { throw UnauthenticatedException () } }","title":"Response type"},{"location":"actions/#grpc-actions","text":"Misk has support for gRPC actions via the Wire protocol buffer (protobuf) library. To create a gRPC action, first define the relevant protos for your service. Let\u2019s say we\u2019re creating a GreeterService that exposes one API, Hello . Create this file in src/main/proto/hello.proto : syntax = \"proto2\" ; package squareup . cash.hello ; option java_package = \"com.squareup.protos.cash.hello\" ; message HelloRequest { optional string message = 1 ; } message HelloResponse { optional string message = 1 ; } service GreeterService { rpc Hello ( HelloRequest ) returns ( HelloResponse ) {} } Next, in your project\u2019s build file (for this example, build.gradle.kts ), add a dependency on the wire plugin: plugins { id(\"com.squareup.wire\") } Add the following configuration to generate the gRPC interfaces for your service: wire { sourcePath { srcDir(\"src/main/proto\") } kotlin { include(\"squareup.cash.hello.GreeterService\") rpcCallStyle = \"blocking\" rpcRole = \"server\" singleMethodServices = true } java { } } Finally, implement and bind your gRPC action. GreeterServiceHelloBlockingServer is generated by Wire. @Singleton class HelloGrpcAction @Inject internal constructor () : GreeterServiceHelloBlockingServer , WebAction { @Unauthorized override fun Hello ( request : HelloRequest ): HelloResponse { return HelloResponse ( \"message\" ) } } // This module binds HelloGrpcAction. class GreeterActionModule : KAbstractModule () { override fun configure () { install ( WebActionModule . create < HelloGrpcAction > ()) } } Creating a gRPC action automatically creates a JSON endpoint with all of the same annotations in the path defined by the ...BlockingServer , typically /<package>.<service name>/<rpc name> . You can also create a second class that extends WebAction to customize this further. Read more about HTTP actions in Web Actions . If you\u2019re building both a gRPC and a HTTP action, a common pattern is to have them both use a common dependency: @Singleton class HelloGrpcAction @Inject constructor ( val greeter : Greeter ) : GreeterServiceHelloBlockingServer , WebAction { @Unauthorized override fun hello () = HelloResponse ( greeter . greet ()) } @Singleton class HelloWebAction @Inject constructor ( val greeter : Greeter ) : WebAction { @Unauthorized @Get ( \"/hello\" ) @ResponseContentType ( MediaTypes . APPLICATION_JSON ) fun hello () = HelloResponse ( greeter . greet ()) } @Singleton class Greeter @Inject constructor () { fun greet () = \"Hello world\" }","title":"gRPC Actions"},{"location":"actions/#actionscoped","text":"ActionScoped gives an action access to context produced by the action\u2019s interceptors. Misk has a few ActionScoped items built in: MiskCaller - access derived authorization details HttpCall - access lower level HTTP details, e.g. request headers","title":"ActionScoped"},{"location":"changelog/","text":"Change Log \u00b6 Version 0.21.0 (2021-10-18) \u00b6 Unstable public release. Version 0.20.0 (2021-08-31) \u00b6 Unstable public release. Breaking changes: Leases now use a different package Wisp Lease API is changing to handle explicit acquire/release on lease (#2113) Log on properties present in config yaml but not in object (#2118) Config now requires defaults for primitive types Move misk admin components to misk-admin (#2065) Reinstate WebActionExceptionMapper sending a response body based on the WebActionException\u2019s responseBody (#2050) New features and fixes: Add incr and incrBy operations to misk-redis (#2119) Add @fetch as a valid hibernate query annotation (#2112) When evaluating JSON LD feature flags, log unknown fields once (#2086) Make additional jooq configurations possible (#2078) Log a warning if health checks fail (#2063) Add support for double feature flags (#2029) Send gRPC errors properly (#1983) Bump log level for invalid access (#2024) misk-policy: To query specific paths, treat document path as urlencoded (#2030) Create LaunchDarkly in Wisp (#2088) Version 0.19.0 (2021-06-30) \u00b6 Unstable public release. Version 0.18.0 (2021-06-28) \u00b6 Unstable public release. Version 0.17.1 (2021-04-29) \u00b6 Unstable public release. Version 0.17.0 (2021-04-28) \u00b6 Unstable public release. Version 0.16.0 (2020-12-17) \u00b6 Unstable public release. Version 0.15.0 (2020-12-03) \u00b6 Unstable public release. Version 0.14.0 (2020-11-12) \u00b6 Unstable public release. Version 0.13.0 (2020-07-16) \u00b6 Unstable public release. Version 0.12.0 (2020-05-06) \u00b6 Unstable public release. Version 0.11.0 (2020-02-25) \u00b6 Unstable public release. Version 0.10.0 (2019-01-21) \u00b6 Unstable public release. Version 0.9.0 (2019-12-06) \u00b6 Unstable public release. Version 0.8.0 (2019-10-22) \u00b6 Unstable public release. Version 0.7.0 (2019-08-26) \u00b6 Unstable public release. Version 0.2.5 (2018-06-11) \u00b6 New \u00b6 Cluster interface and DataSourceCluster bindings Add a JPAEntityModule for binding entities for a DataSource Hook up raw Hibernate APIs Use JPA entity types in HibernateModule. Introduce FakeResourceLoader SchemaMigrator for running and tracking schema migrations. Update Misk version in Dockerfiles to 0.2.5 Drop support for unqualified datasources. move exemplars into sample directory in preparation for more of them Make all Kotlin warnings build errors Allow services to specify dependencies on other services. Fast fail on dependency cycles. jre8 was deprecated for kotlin 1.2 Early types for the Transacter APIs Queries in the Misk Hibernate API. Implement Query with dynamic proxies and reflection Offer strict validation and nice errors in ReflectionQueryFactory Log the reasons why liveness/readiness checks fail URL shortener sample Support more operators in Query Wire up Hibernate event listeners through Guice. HibernateTestingModule. Switch tests to MySQL Rollback transactions on exceptions Delete DataSourceModule. It\u2019s redundant with HibernateModule. Support ByteString columns Misk containers should not run as root DbTimestampedEntity Fix \u00b6 Don\u2019t inject until after services are started. Tidy up some test cases. Fix a missing dependency in exemplar Don\u2019t use KubernetesHealthCheck with LocalClusterConnector Version 0.2.4 (2018-05-14) \u00b6 New \u00b6 Add support for protobuf over HTTP Cloudwatch Trail logging support Add retry() helper Add Backoff/ExponentialBackoff MiskCaller and authz support Adds a DataSourceModule Add support for logging to StackDriver Fix \u00b6 Move static resources from web root into resources Move web-specific NetworkInterceptor into web Remove use of instance metadata endpoints Version 0.2.3 (2018-04-27) \u00b6 New \u00b6 Add kubernetes java client so that hosts can know their peers Use EventRouter for exemplarchat. Add a static resource mapper Create a cluster wide admin healthcheck page Change CacheBuilder to be mapOf since no concurrency Adds a healthcheck for the kubernetes client Adds a local cluster connector so that development functions Fix \u00b6 Don\u2019t treat assembly as a release when running in CI Fix tracing startup when none is configured Various event router fixes and refactorings Version 0.2.1 (2018-03-26) \u00b6 New \u00b6 Remove unnecessary check from uploadArchives task (#149) Add a RELEASING.md to outline misk release process (#150) Move chat into its own example project. (#146) Introduce event router api (#147) Add basic frontend for exemplarchat Add MoshiJsonAdapters and SocketEventJsonAdapter (#151) Expose client certificates as action scoped vars (#141) Add ClusterMapper interface, refactor RealEventRouter to event loop (#155) Handle cluster changes (#156) More tests to exercise EventRouter behaviors. (#158) Support loading keystores from combined private key and certificate chain PEM files (#157) Fix \u00b6 Fix event router tests (#159) Version 0.2.0 (2018-03-13) \u00b6 New \u00b6 Add _status action Split Interceptor into NetworkInterceptor and ApplicationInterceptor Introduce websocket support in misk Add tracing interceptor for web actions Add ActionExceptionLogLevelConfig to control log levels for ActionExceptions Allow binding an ExceptionMapper by an Exception type Google Cloud Datastore and Cloud Storage support Add backend for Zipkin tracer Add MiskTracer to facilitate ad-hoc method tracing Retrofit based typed client support (#112) Enable SSL for both clients and servers (#111) Support application/x-www-form-urlencoded parameters (#97) Add API for injecting dynamically sourced flags Add metrics backend for SignalFx Add support for commands Upgrade to Gradle 4.5 to support Java 9; add Java 9 to test matrix Allow customized exception mappings Add support for query strings in urls Fix \u00b6 Eliminate redundant _config suffix in config files Support Web actions that return Nothing Use proper snake-casing for default property names Fix Java path param dispatching Fix NotFoundAction handling (#134) Fix wildcard based content routing Fix a bug when a user-defined Interceptor returns a Response object Fix up Java translation from Moshi. (#107) Version 0.1.0 (2018-02-01) \u00b6 Initial release.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-0210-2021-10-18","text":"Unstable public release.","title":"Version 0.21.0 (2021-10-18)"},{"location":"changelog/#version-0200-2021-08-31","text":"Unstable public release. Breaking changes: Leases now use a different package Wisp Lease API is changing to handle explicit acquire/release on lease (#2113) Log on properties present in config yaml but not in object (#2118) Config now requires defaults for primitive types Move misk admin components to misk-admin (#2065) Reinstate WebActionExceptionMapper sending a response body based on the WebActionException\u2019s responseBody (#2050) New features and fixes: Add incr and incrBy operations to misk-redis (#2119) Add @fetch as a valid hibernate query annotation (#2112) When evaluating JSON LD feature flags, log unknown fields once (#2086) Make additional jooq configurations possible (#2078) Log a warning if health checks fail (#2063) Add support for double feature flags (#2029) Send gRPC errors properly (#1983) Bump log level for invalid access (#2024) misk-policy: To query specific paths, treat document path as urlencoded (#2030) Create LaunchDarkly in Wisp (#2088)","title":"Version 0.20.0 (2021-08-31)"},{"location":"changelog/#version-0190-2021-06-30","text":"Unstable public release.","title":"Version 0.19.0 (2021-06-30)"},{"location":"changelog/#version-0180-2021-06-28","text":"Unstable public release.","title":"Version 0.18.0 (2021-06-28)"},{"location":"changelog/#version-0171-2021-04-29","text":"Unstable public release.","title":"Version 0.17.1 (2021-04-29)"},{"location":"changelog/#version-0170-2021-04-28","text":"Unstable public release.","title":"Version 0.17.0 (2021-04-28)"},{"location":"changelog/#version-0160-2020-12-17","text":"Unstable public release.","title":"Version 0.16.0 (2020-12-17)"},{"location":"changelog/#version-0150-2020-12-03","text":"Unstable public release.","title":"Version 0.15.0 (2020-12-03)"},{"location":"changelog/#version-0140-2020-11-12","text":"Unstable public release.","title":"Version 0.14.0 (2020-11-12)"},{"location":"changelog/#version-0130-2020-07-16","text":"Unstable public release.","title":"Version 0.13.0 (2020-07-16)"},{"location":"changelog/#version-0120-2020-05-06","text":"Unstable public release.","title":"Version 0.12.0 (2020-05-06)"},{"location":"changelog/#version-0110-2020-02-25","text":"Unstable public release.","title":"Version 0.11.0 (2020-02-25)"},{"location":"changelog/#version-0100-2019-01-21","text":"Unstable public release.","title":"Version 0.10.0 (2019-01-21)"},{"location":"changelog/#version-090-2019-12-06","text":"Unstable public release.","title":"Version 0.9.0 (2019-12-06)"},{"location":"changelog/#version-080-2019-10-22","text":"Unstable public release.","title":"Version 0.8.0 (2019-10-22)"},{"location":"changelog/#version-070-2019-08-26","text":"Unstable public release.","title":"Version 0.7.0 (2019-08-26)"},{"location":"changelog/#version-025-2018-06-11","text":"","title":"Version 0.2.5 (2018-06-11)"},{"location":"changelog/#new","text":"Cluster interface and DataSourceCluster bindings Add a JPAEntityModule for binding entities for a DataSource Hook up raw Hibernate APIs Use JPA entity types in HibernateModule. Introduce FakeResourceLoader SchemaMigrator for running and tracking schema migrations. Update Misk version in Dockerfiles to 0.2.5 Drop support for unqualified datasources. move exemplars into sample directory in preparation for more of them Make all Kotlin warnings build errors Allow services to specify dependencies on other services. Fast fail on dependency cycles. jre8 was deprecated for kotlin 1.2 Early types for the Transacter APIs Queries in the Misk Hibernate API. Implement Query with dynamic proxies and reflection Offer strict validation and nice errors in ReflectionQueryFactory Log the reasons why liveness/readiness checks fail URL shortener sample Support more operators in Query Wire up Hibernate event listeners through Guice. HibernateTestingModule. Switch tests to MySQL Rollback transactions on exceptions Delete DataSourceModule. It\u2019s redundant with HibernateModule. Support ByteString columns Misk containers should not run as root DbTimestampedEntity","title":"New"},{"location":"changelog/#fix","text":"Don\u2019t inject until after services are started. Tidy up some test cases. Fix a missing dependency in exemplar Don\u2019t use KubernetesHealthCheck with LocalClusterConnector","title":"Fix"},{"location":"changelog/#version-024-2018-05-14","text":"","title":"Version 0.2.4 (2018-05-14)"},{"location":"changelog/#new_1","text":"Add support for protobuf over HTTP Cloudwatch Trail logging support Add retry() helper Add Backoff/ExponentialBackoff MiskCaller and authz support Adds a DataSourceModule Add support for logging to StackDriver","title":"New"},{"location":"changelog/#fix_1","text":"Move static resources from web root into resources Move web-specific NetworkInterceptor into web Remove use of instance metadata endpoints","title":"Fix"},{"location":"changelog/#version-023-2018-04-27","text":"","title":"Version 0.2.3 (2018-04-27)"},{"location":"changelog/#new_2","text":"Add kubernetes java client so that hosts can know their peers Use EventRouter for exemplarchat. Add a static resource mapper Create a cluster wide admin healthcheck page Change CacheBuilder to be mapOf since no concurrency Adds a healthcheck for the kubernetes client Adds a local cluster connector so that development functions","title":"New"},{"location":"changelog/#fix_2","text":"Don\u2019t treat assembly as a release when running in CI Fix tracing startup when none is configured Various event router fixes and refactorings","title":"Fix"},{"location":"changelog/#version-021-2018-03-26","text":"","title":"Version 0.2.1 (2018-03-26)"},{"location":"changelog/#new_3","text":"Remove unnecessary check from uploadArchives task (#149) Add a RELEASING.md to outline misk release process (#150) Move chat into its own example project. (#146) Introduce event router api (#147) Add basic frontend for exemplarchat Add MoshiJsonAdapters and SocketEventJsonAdapter (#151) Expose client certificates as action scoped vars (#141) Add ClusterMapper interface, refactor RealEventRouter to event loop (#155) Handle cluster changes (#156) More tests to exercise EventRouter behaviors. (#158) Support loading keystores from combined private key and certificate chain PEM files (#157)","title":"New"},{"location":"changelog/#fix_3","text":"Fix event router tests (#159)","title":"Fix"},{"location":"changelog/#version-020-2018-03-13","text":"","title":"Version 0.2.0 (2018-03-13)"},{"location":"changelog/#new_4","text":"Add _status action Split Interceptor into NetworkInterceptor and ApplicationInterceptor Introduce websocket support in misk Add tracing interceptor for web actions Add ActionExceptionLogLevelConfig to control log levels for ActionExceptions Allow binding an ExceptionMapper by an Exception type Google Cloud Datastore and Cloud Storage support Add backend for Zipkin tracer Add MiskTracer to facilitate ad-hoc method tracing Retrofit based typed client support (#112) Enable SSL for both clients and servers (#111) Support application/x-www-form-urlencoded parameters (#97) Add API for injecting dynamically sourced flags Add metrics backend for SignalFx Add support for commands Upgrade to Gradle 4.5 to support Java 9; add Java 9 to test matrix Allow customized exception mappings Add support for query strings in urls","title":"New"},{"location":"changelog/#fix_4","text":"Eliminate redundant _config suffix in config files Support Web actions that return Nothing Use proper snake-casing for default property names Fix Java path param dispatching Fix NotFoundAction handling (#134) Fix wildcard based content routing Fix a bug when a user-defined Interceptor returns a Response object Fix up Java translation from Moshi. (#107)","title":"Fix"},{"location":"changelog/#version-010-2018-02-01","text":"Initial release.","title":"Version 0.1.0 (2018-02-01)"},{"location":"clients/","text":"Clients \u00b6 Misk provides configurable HTTP clients built on top of OkHttp and Retrofit , and gRPC clients built on top of Wire . HTTP Clients \u00b6 Config \u00b6 Set up a Config object (and use MiskConfig.load to load config from a YAML file): data class MyServiceConfig ( val http_clients : HttpClientsConfig , // ... ) : Config In the configuration YAML, specify the target service\u2019s address: http_clients : ... endpoints : ... greeter : { url : \"https://hello.example.com\" } Create an OkHttpClient \u00b6 Use HttpClientModule : class MyClientModule : KAbstractModule () { override fun configure () { install ( HttpClientModule ( // Corresponds to the YAML config. Requires a bound HttpClientsConfig name = \"greeter\" , // Optional annotation to define how you inject your client dependency annotation = Names . named ( \"greeterHttp\" ) )) } } This binds an OkHttpClient that you can inject: class MyClient @Inject constructor ( @Named ( \"greeterHttp\" ) val client : OkHttpClient ) { fun callGreeter () { val response = client . newCall ( Request . Builder () . url ( \"http://localhost:8080/hello\" ) . build () ). execute () } } Create typed clients with Retrofit \u00b6 First, create a Retrofit interface. See the Retrofit docs for more details. interface GreeterApi { @POST ( \"/hello\" ) @Headers ( value = [ \"accept: application/json\" ] ) fun hello ( @Body request : HelloRequest ): Call < HelloResponse > } Next, install a TypedHttpClientModule with this interface. class HelloClientModule : KAbstractModule () { override fun configure () { install ( TypedHttpClientModule ( GreeterApi :: class , // Corresponds to the YAML config. Requires a bound HttpClientsConfig name = \"greeter\" , // Optional annotation to define how you inject your client dependency annotation = Names . named ( \"greeterApi\" ) ) ) } } Now you can inject an implementation of this client: @Singleton class MyApiClient @Inject constructor ( @Named ( \"greeterApi\" ) private val api : GreeterApi ) { fun hello ( message : String ): String { val response = api . hello ( HelloRequest ( message = message ) ). execute () } } gRPC Clients \u00b6 First, include the auto-generated gRPC client code at the caller module using the Wire Gradle plugin. plugins { id(\"com.squareup.wire\") } wire { sourcePath { srcDir(\"src/main/proto\") } // Generate Kotlin for the gRPC client API. kotlin { // Set this to false if you're generating client and server interfaces in one module exclusive = false includes (\"squareup.cash.hello.GreeterService\") rpcRole = \"client\" } java { } } Next, bind your client in code in a similar fashion to an HTTP client. Set up client configuration, as described in Config . Then, bind a GrpcClientModule : class GreeterClientModule : KAbstractModule () { override fun configure () { install ( GrpcClientModule . create < GreeterServiceClient , GrpcGreeterServiceClient > ( // Corresponds to the YAML config. Requires a bound HttpClientsConfig name = \"greeter\" , // Optional annotation to define how you inject your client dependency annotation = Names . named ( \"greeterGrpc\" ) )) } } With this all setup, you can now inject your client in source code and connect via gRPC: internal class GrpcGreeterServiceClient @Inject internal constructor ( @Named ( \"greeterGrpc\" ) private val greeterGrpc : GreeterServiceClient ) { fun get ( message : String ) { val response = greeterGrpc . Hello (). executeBlocking ( HelloRequest ( message )) // ... do something with the response here } }","title":"Clients"},{"location":"clients/#clients","text":"Misk provides configurable HTTP clients built on top of OkHttp and Retrofit , and gRPC clients built on top of Wire .","title":"Clients"},{"location":"clients/#http-clients","text":"","title":"HTTP Clients"},{"location":"clients/#config","text":"Set up a Config object (and use MiskConfig.load to load config from a YAML file): data class MyServiceConfig ( val http_clients : HttpClientsConfig , // ... ) : Config In the configuration YAML, specify the target service\u2019s address: http_clients : ... endpoints : ... greeter : { url : \"https://hello.example.com\" }","title":"Config"},{"location":"clients/#create-an-okhttpclient","text":"Use HttpClientModule : class MyClientModule : KAbstractModule () { override fun configure () { install ( HttpClientModule ( // Corresponds to the YAML config. Requires a bound HttpClientsConfig name = \"greeter\" , // Optional annotation to define how you inject your client dependency annotation = Names . named ( \"greeterHttp\" ) )) } } This binds an OkHttpClient that you can inject: class MyClient @Inject constructor ( @Named ( \"greeterHttp\" ) val client : OkHttpClient ) { fun callGreeter () { val response = client . newCall ( Request . Builder () . url ( \"http://localhost:8080/hello\" ) . build () ). execute () } }","title":"Create an OkHttpClient"},{"location":"clients/#create-typed-clients-with-retrofit","text":"First, create a Retrofit interface. See the Retrofit docs for more details. interface GreeterApi { @POST ( \"/hello\" ) @Headers ( value = [ \"accept: application/json\" ] ) fun hello ( @Body request : HelloRequest ): Call < HelloResponse > } Next, install a TypedHttpClientModule with this interface. class HelloClientModule : KAbstractModule () { override fun configure () { install ( TypedHttpClientModule ( GreeterApi :: class , // Corresponds to the YAML config. Requires a bound HttpClientsConfig name = \"greeter\" , // Optional annotation to define how you inject your client dependency annotation = Names . named ( \"greeterApi\" ) ) ) } } Now you can inject an implementation of this client: @Singleton class MyApiClient @Inject constructor ( @Named ( \"greeterApi\" ) private val api : GreeterApi ) { fun hello ( message : String ): String { val response = api . hello ( HelloRequest ( message = message ) ). execute () } }","title":"Create typed clients with Retrofit"},{"location":"clients/#grpc-clients","text":"First, include the auto-generated gRPC client code at the caller module using the Wire Gradle plugin. plugins { id(\"com.squareup.wire\") } wire { sourcePath { srcDir(\"src/main/proto\") } // Generate Kotlin for the gRPC client API. kotlin { // Set this to false if you're generating client and server interfaces in one module exclusive = false includes (\"squareup.cash.hello.GreeterService\") rpcRole = \"client\" } java { } } Next, bind your client in code in a similar fashion to an HTTP client. Set up client configuration, as described in Config . Then, bind a GrpcClientModule : class GreeterClientModule : KAbstractModule () { override fun configure () { install ( GrpcClientModule . create < GreeterServiceClient , GrpcGreeterServiceClient > ( // Corresponds to the YAML config. Requires a bound HttpClientsConfig name = \"greeter\" , // Optional annotation to define how you inject your client dependency annotation = Names . named ( \"greeterGrpc\" ) )) } } With this all setup, you can now inject your client in source code and connect via gRPC: internal class GrpcGreeterServiceClient @Inject internal constructor ( @Named ( \"greeterGrpc\" ) private val greeterGrpc : GreeterServiceClient ) { fun get ( message : String ) { val response = greeterGrpc . Hello (). executeBlocking ( HelloRequest ( message )) // ... do something with the response here } }","title":"gRPC Clients"},{"location":"contributing/","text":"Contributing \u00b6 If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) . Building Misk locally \u00b6 Use gradle to run all Kotlin tests locally: ./gradlew build misk-hibernate tests expect a mysql server running on localhost:3306 with no password set on the root user. You might stand up a server with a docker image, e.g. docker run -d --rm --name \"mysql-57\" -p 3306 :3306 -e MYSQL_ALLOW_EMPTY_PASSWORD = true -e MYSQL_LOG_CONSOLE = true mysql:5.7 --sql-mode = \"\" Breaking changes \u00b6 We use the Kotlin binary compatibility validator to check for API changes. If a change contains an API change and breaks the build, run the :apiDump task and commit the resulting changes to the .api files. .api files should not have removals and additions in the same change so that downstream apps do not immediately run into backwards-compatibility issues.","title":"Contributing"},{"location":"contributing/#contributing","text":"If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request. When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#building-misk-locally","text":"Use gradle to run all Kotlin tests locally: ./gradlew build misk-hibernate tests expect a mysql server running on localhost:3306 with no password set on the root user. You might stand up a server with a docker image, e.g. docker run -d --rm --name \"mysql-57\" -p 3306 :3306 -e MYSQL_ALLOW_EMPTY_PASSWORD = true -e MYSQL_LOG_CONSOLE = true mysql:5.7 --sql-mode = \"\"","title":"Building Misk locally"},{"location":"contributing/#breaking-changes","text":"We use the Kotlin binary compatibility validator to check for API changes. If a change contains an API change and breaks the build, run the :apiDump task and commit the resulting changes to the .api files. .api files should not have removals and additions in the same change so that downstream apps do not immediately run into backwards-compatibility issues.","title":"Breaking changes"},{"location":"getting-started/","text":"Getting Started \u00b6 Misk is an application container for Kotlin. It provides libraries for common application concerns like serving endpoints, caching, queueing, persistence, distributed leasing, and clustering. The easiest way to get started is to copy the Misk exemplar project . This exemplar contains a Misk web app with the requisite dependencies. Start the service \u00b6 Run ExemplarService#main , or use gradle to run: ./gradlew run Set up bindings \u00b6 A Misk application is wired together using Guice . Features of Misk are managed by Guava Services , provided by Guice Modules , and configured using Misk Config s. For example, if your application needs a Redis cache, you would install RedisModule , and add a corresponding RedisConfig to your application\u2019s config YAML. Misk is unopinionated about which of its features your application chooses to use, and offers multiple alternatives for some common concerns. The main function \u00b6 The entry point to every Misk application is MiskApplication : fun main ( args : Array < String > ) { val environment = Environment . fromEnvironmentVariable () val env = Env ( environment . name ) val config = MiskConfig . load < ExemplarConfig > ( \"exemplar\" , env ) MiskApplication ( MiskRealServiceModule (), MiskWebModule ( config . web ), ExemplarAccessModule (), ExemplarWebActionsModule (), // e.g. to add an admin dashboard: AdminDashboardModule ( isDevelopment = true ) ). run ( args ) } Set up configuration \u00b6 Every Misk application has a top-level class that implements the Config marker interface. This Config encapsulates all of the configuration for the app. By default, configs are loaded from YAML files at the app\u2019s resources root. Each value in the config must have a corresponding entry in the YAML file. Modules in Misk that require configuration usually have their own Config objects. If you want to use the Module in your app, you should add them as properties of your app\u2019s Config object, for example: data class MyAppConfig ( val my_config_value : String , val http_clients : HttpClientsConfig ) : Config This then corresponds to a YAML file: my_config_value : \"this value\" http_clients : # ... config Config resolution \u00b6 Configs are loaded using the app\u2019s resource loader. The config loader looks for files in the following order by default: $SERVICE_NAME-common.yaml $SERVICE_NAME-$ENVIRONMENT.yaml At least one of $SERVICE_NAME-common.yaml or $SERVICE_NAME-$ENVIRONMENT.yaml must exist. Values from later files take precedence. Write an endpoint \u00b6 Actions are Misk\u2019s unit for an endpoint. Actions inherit from WebAction and have a @Get / @Post annotation: @Singleton class HelloWebAction @Inject constructor () : WebAction { @Get ( \"/hello/{name}\" ) @Unauthenticated @ResponseContentType ( MediaTypes . APPLICATION_JSON ) fun hello ( @PathParam name : String , ): HelloResponse { return HelloResponse ( name ) } } data class HelloResponse ( val name : String ) Read more about this in Actions . Test the endpoint \u00b6 You can unit test directly: class HelloWebActionTest { @Test fun `tests the unit` () { assertThat ( HelloWebAction (). hello ( \"sandy\" , headersOf (), null , null )) . isEqualTo ( HelloResponse ( \"sandy\" )) } } Integration tests set up a module for you, and adds an injector to the test class. You can use WebTestingModule to set up a running web server and make WebTestClient available. @MiskTest ( startService = true ) class HelloWebActionTest { @MiskTestModule val module = TestModule () @Inject private lateinit var webTestClient : WebTestClient @Test fun `tests a request being made` () { val hello = webTestClient . get ( \"/hello/sandy\" ) assertThat ( hello . response . code ). isEqualTo ( 200 ) assertThat ( hello . parseJson < HelloResponse > ()) . isEqualTo ( HelloResponse ( \"sandy\" )) } class TestModule : KAbstractModule () { override fun configure () { install ( WebTestingModule ()) install ( HelloModule ()) } } } Create services \u00b6 The main function is just an entry point for wiring together components of Misk. Long-running threads that do the real work are written as Services using Guava\u2019s Service Framework . A Service is bound by installing a ServiceModule , for example: class MyServiceModule : KAbstractModule () { override fun configure () { install ( ServiceModule < MyService > ()) } } Notice that in this examplewe use KAbstractModule() , Misk\u2019s Kotlin wrapper for AbstractModule , as our base Module class. MiskApplication will start all services installed by a ServiceModule . If there is a Service that must be run after a other set of Services have started, the service dependency graph should be specified at the installation site. For example, if you are operating a movie service, which needs a database: class MovieServiceModule : KAbstractModule () { override fun configure () { // Note that DatabaseService does not have to be installed here. // It could be installed in another KAbstractModule if preferred. install ( ServiceModule < DatabaseService > ()) // Multiple dependencies can be added by chaining calls to `dependsOn`. install ( ServiceModule < MovieService > () . dependsOn < DatabaseService > ()) } } See ServiceModule for more details about the service graph. When writing Services , always prefer to inherit from one of the common base classes: AbstractIdleService , AbstractScheduledService , or AbstractExecutionThreadService . See Services Explained for details. If your service is can make use of exponential backoff and scheduling, take a look at using RepeatedTaskQueue .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Misk is an application container for Kotlin. It provides libraries for common application concerns like serving endpoints, caching, queueing, persistence, distributed leasing, and clustering. The easiest way to get started is to copy the Misk exemplar project . This exemplar contains a Misk web app with the requisite dependencies.","title":"Getting Started"},{"location":"getting-started/#start-the-service","text":"Run ExemplarService#main , or use gradle to run: ./gradlew run","title":"Start the service"},{"location":"getting-started/#set-up-bindings","text":"A Misk application is wired together using Guice . Features of Misk are managed by Guava Services , provided by Guice Modules , and configured using Misk Config s. For example, if your application needs a Redis cache, you would install RedisModule , and add a corresponding RedisConfig to your application\u2019s config YAML. Misk is unopinionated about which of its features your application chooses to use, and offers multiple alternatives for some common concerns.","title":"Set up bindings"},{"location":"getting-started/#the-main-function","text":"The entry point to every Misk application is MiskApplication : fun main ( args : Array < String > ) { val environment = Environment . fromEnvironmentVariable () val env = Env ( environment . name ) val config = MiskConfig . load < ExemplarConfig > ( \"exemplar\" , env ) MiskApplication ( MiskRealServiceModule (), MiskWebModule ( config . web ), ExemplarAccessModule (), ExemplarWebActionsModule (), // e.g. to add an admin dashboard: AdminDashboardModule ( isDevelopment = true ) ). run ( args ) }","title":"The main function"},{"location":"getting-started/#set-up-configuration","text":"Every Misk application has a top-level class that implements the Config marker interface. This Config encapsulates all of the configuration for the app. By default, configs are loaded from YAML files at the app\u2019s resources root. Each value in the config must have a corresponding entry in the YAML file. Modules in Misk that require configuration usually have their own Config objects. If you want to use the Module in your app, you should add them as properties of your app\u2019s Config object, for example: data class MyAppConfig ( val my_config_value : String , val http_clients : HttpClientsConfig ) : Config This then corresponds to a YAML file: my_config_value : \"this value\" http_clients : # ... config","title":"Set up configuration"},{"location":"getting-started/#config-resolution","text":"Configs are loaded using the app\u2019s resource loader. The config loader looks for files in the following order by default: $SERVICE_NAME-common.yaml $SERVICE_NAME-$ENVIRONMENT.yaml At least one of $SERVICE_NAME-common.yaml or $SERVICE_NAME-$ENVIRONMENT.yaml must exist. Values from later files take precedence.","title":"Config resolution"},{"location":"getting-started/#write-an-endpoint","text":"Actions are Misk\u2019s unit for an endpoint. Actions inherit from WebAction and have a @Get / @Post annotation: @Singleton class HelloWebAction @Inject constructor () : WebAction { @Get ( \"/hello/{name}\" ) @Unauthenticated @ResponseContentType ( MediaTypes . APPLICATION_JSON ) fun hello ( @PathParam name : String , ): HelloResponse { return HelloResponse ( name ) } } data class HelloResponse ( val name : String ) Read more about this in Actions .","title":"Write an endpoint"},{"location":"getting-started/#test-the-endpoint","text":"You can unit test directly: class HelloWebActionTest { @Test fun `tests the unit` () { assertThat ( HelloWebAction (). hello ( \"sandy\" , headersOf (), null , null )) . isEqualTo ( HelloResponse ( \"sandy\" )) } } Integration tests set up a module for you, and adds an injector to the test class. You can use WebTestingModule to set up a running web server and make WebTestClient available. @MiskTest ( startService = true ) class HelloWebActionTest { @MiskTestModule val module = TestModule () @Inject private lateinit var webTestClient : WebTestClient @Test fun `tests a request being made` () { val hello = webTestClient . get ( \"/hello/sandy\" ) assertThat ( hello . response . code ). isEqualTo ( 200 ) assertThat ( hello . parseJson < HelloResponse > ()) . isEqualTo ( HelloResponse ( \"sandy\" )) } class TestModule : KAbstractModule () { override fun configure () { install ( WebTestingModule ()) install ( HelloModule ()) } } }","title":"Test the endpoint"},{"location":"getting-started/#create-services","text":"The main function is just an entry point for wiring together components of Misk. Long-running threads that do the real work are written as Services using Guava\u2019s Service Framework . A Service is bound by installing a ServiceModule , for example: class MyServiceModule : KAbstractModule () { override fun configure () { install ( ServiceModule < MyService > ()) } } Notice that in this examplewe use KAbstractModule() , Misk\u2019s Kotlin wrapper for AbstractModule , as our base Module class. MiskApplication will start all services installed by a ServiceModule . If there is a Service that must be run after a other set of Services have started, the service dependency graph should be specified at the installation site. For example, if you are operating a movie service, which needs a database: class MovieServiceModule : KAbstractModule () { override fun configure () { // Note that DatabaseService does not have to be installed here. // It could be installed in another KAbstractModule if preferred. install ( ServiceModule < DatabaseService > ()) // Multiple dependencies can be added by chaining calls to `dependsOn`. install ( ServiceModule < MovieService > () . dependsOn < DatabaseService > ()) } } See ServiceModule for more details about the service graph. When writing Services , always prefer to inherit from one of the common base classes: AbstractIdleService , AbstractScheduledService , or AbstractExecutionThreadService . See Services Explained for details. If your service is can make use of exponential backoff and scheduling, take a look at using RepeatedTaskQueue .","title":"Create services"},{"location":"releasing-manual/","text":"Manual Releasing Steps \u00b6 These should generally not be needed but are kept here for posterity. The CI auto-releasing in Github Actions should be sufficient, and is documented in the Releasing doc. Prerequisite: Sonatype (Maven Central) Account \u00b6 Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for misk projects. Prerequisite: GPG Keys \u00b6 Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@cash.app> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX Prerequisite: Gradle Properties \u00b6 Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jwilson/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg Cutting a Release \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.misk:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.misk:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` miskweb ci-build -e ./gradlew clean uploadArchives Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a misk-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Manual Releasing"},{"location":"releasing-manual/#manual-releasing-steps","text":"These should generally not be needed but are kept here for posterity. The CI auto-releasing in Github Actions should be sufficient, and is documented in the Releasing doc.","title":"Manual Releasing Steps"},{"location":"releasing-manual/#prerequisite-sonatype-maven-central-account","text":"Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for misk projects.","title":"Prerequisite: Sonatype (Maven Central) Account"},{"location":"releasing-manual/#prerequisite-gpg-keys","text":"Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@cash.app> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX","title":"Prerequisite: GPG Keys"},{"location":"releasing-manual/#prerequisite-gradle-properties","text":"Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jwilson/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg","title":"Prerequisite: Gradle Properties"},{"location":"releasing-manual/#cutting-a-release","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.misk:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.misk:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` miskweb ci-build -e ./gradlew clean uploadArchives Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a misk-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Cutting a Release"},{"location":"releasing/","text":"Releasing \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=A.B.C export NEXT_VERSION=A.B.D-SNAPSHOT Update documentation and Gradle properties with RELEASE_VERSION sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.misk:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.misk:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -maxdepth 2 -name \"README.md\"` Tag the release and push to GitHub. Merge PR. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a misk-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" git push && git push --tags Trigger the \u201cPublish a release\u201d action manually. Wait until it completes, then visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Prepare for the next release and push to GitHub. Merge PR. sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push Draft a new release of A.B.C to trigger the \u201cPublish the mkdocs to gh-pages\u201d action. Troubleshooting \u00b6 If the github action fails, drop the artifacts from Sonatype and re run the job. You might need to delete the plugin off the JetBrains plugin portal first if the ubuntu job which publishes it already succeeded.","title":"Releasing"},{"location":"releasing/#releasing","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=A.B.C export NEXT_VERSION=A.B.D-SNAPSHOT Update documentation and Gradle properties with RELEASE_VERSION sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.misk:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.misk:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -maxdepth 2 -name \"README.md\"` Tag the release and push to GitHub. Merge PR. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a misk-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" git push && git push --tags Trigger the \u201cPublish a release\u201d action manually. Wait until it completes, then visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Prepare for the next release and push to GitHub. Merge PR. sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push Draft a new release of A.B.C to trigger the \u201cPublish the mkdocs to gh-pages\u201d action.","title":"Releasing"},{"location":"releasing/#troubleshooting","text":"If the github action fails, drop the artifacts from Sonatype and re run the job. You might need to delete the plugin off the JetBrains plugin portal first if the ubuntu job which publishes it already succeeded.","title":"Troubleshooting"}]}